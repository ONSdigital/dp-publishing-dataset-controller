// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package dataset

import (
	"context"
	datasetclient "github.com/ONSdigital/dp-api-clients-go/v2/dataset"
	zebedeeclient "github.com/ONSdigital/dp-api-clients-go/v2/zebedee"
	babbageclient "github.com/ONSdigital/dp-publishing-dataset-controller/clients/topics"
	"sync"
)

// Ensure, that DatasetClientMock does implement DatasetClient.
// If this is not the case, regenerate this file with moq.
var _ DatasetClient = &DatasetClientMock{}

// DatasetClientMock is a mock implementation of DatasetClient.
//
//	func TestSomethingThatUsesDatasetClient(t *testing.T) {
//
//		// make and configure a mocked DatasetClient
//		mockedDatasetClient := &DatasetClientMock{
//			GetFunc: func(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, datasetID string) (datasetclient.DatasetDetails, error) {
//				panic("mock out the Get method")
//			},
//			GetDatasetCurrentAndNextFunc: func(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, datasetID string) (datasetclient.Dataset, error) {
//				panic("mock out the GetDatasetCurrentAndNext method")
//			},
//			GetDatasetsInBatchesFunc: func(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, batchSize int, maxWorkers int) (datasetclient.List, error) {
//				panic("mock out the GetDatasetsInBatches method")
//			},
//			GetEditionFunc: func(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, datasetID string, edition string) (datasetclient.Edition, error) {
//				panic("mock out the GetEdition method")
//			},
//			GetEditionsFunc: func(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, datasetID string) ([]datasetclient.Edition, error) {
//				panic("mock out the GetEditions method")
//			},
//			GetInstanceFunc: func(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, instanceID string, ifMatch string) (datasetclient.Instance, string, error) {
//				panic("mock out the GetInstance method")
//			},
//			GetVersionFunc: func(ctx context.Context, userAuthToken string, serviceAuthToken string, downloadServiceAuthToken string, collectionID string, datasetID string, edition string, version string) (datasetclient.Version, error) {
//				panic("mock out the GetVersion method")
//			},
//			GetVersionsInBatchesFunc: func(ctx context.Context, userAuthToken string, serviceAuthToken string, downloadServiceAuthToken string, collectionID string, datasetID string, edition string, batchSize int, maxWorkers int) (datasetclient.VersionsList, error) {
//				panic("mock out the GetVersionsInBatches method")
//			},
//			PutDatasetFunc: func(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, datasetID string, d datasetclient.DatasetDetails) error {
//				panic("mock out the PutDataset method")
//			},
//			PutInstanceFunc: func(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, instanceID string, i datasetclient.UpdateInstance, ifMatch string) (string, error) {
//				panic("mock out the PutInstance method")
//			},
//			PutMetadataFunc: func(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, datasetID string, edition string, version string, metadata datasetclient.EditableMetadata, versionEtag string) error {
//				panic("mock out the PutMetadata method")
//			},
//			PutVersionFunc: func(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, datasetID string, edition string, version string, v datasetclient.Version) error {
//				panic("mock out the PutVersion method")
//			},
//		}
//
//		// use mockedDatasetClient in code that requires DatasetClient
//		// and then make assertions.
//
//	}
type DatasetClientMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, datasetID string) (datasetclient.DatasetDetails, error)

	// GetDatasetCurrentAndNextFunc mocks the GetDatasetCurrentAndNext method.
	GetDatasetCurrentAndNextFunc func(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, datasetID string) (datasetclient.Dataset, error)

	// GetDatasetsInBatchesFunc mocks the GetDatasetsInBatches method.
	GetDatasetsInBatchesFunc func(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, batchSize int, maxWorkers int) (datasetclient.List, error)

	// GetEditionFunc mocks the GetEdition method.
	GetEditionFunc func(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, datasetID string, edition string) (datasetclient.Edition, error)

	// GetEditionsFunc mocks the GetEditions method.
	GetEditionsFunc func(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, datasetID string) ([]datasetclient.Edition, error)

	// GetInstanceFunc mocks the GetInstance method.
	GetInstanceFunc func(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, instanceID string, ifMatch string) (datasetclient.Instance, string, error)

	// GetVersionFunc mocks the GetVersion method.
	GetVersionFunc func(ctx context.Context, userAuthToken string, serviceAuthToken string, downloadServiceAuthToken string, collectionID string, datasetID string, edition string, version string) (datasetclient.Version, error)

	// GetVersionWithHeadersFunc mocks the GetVersionWithHeaders method.
	GetVersionWithHeadersFunc func(ctx context.Context, userAuthToken string, serviceAuthToken string, downloadServiceAuthToken string, collectionID string, datasetID string, edition string, version string) (datasetclient.Version, datasetclient.ResponseHeaders, error)

	// GetVersionsInBatchesFunc mocks the GetVersionsInBatches method.
	GetVersionsInBatchesFunc func(ctx context.Context, userAuthToken string, serviceAuthToken string, downloadServiceAuthToken string, collectionID string, datasetID string, edition string, batchSize int, maxWorkers int) (datasetclient.VersionsList, error)

	// PutDatasetFunc mocks the PutDataset method.
	PutDatasetFunc func(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, datasetID string, d datasetclient.DatasetDetails) error

	// PutInstanceFunc mocks the PutInstance method.
	PutInstanceFunc func(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, instanceID string, i datasetclient.UpdateInstance, ifMatch string) (string, error)

	// PutMetadataFunc mocks the PutMetadata method.
	PutMetadataFunc func(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, datasetID string, edition string, version string, metadata datasetclient.EditableMetadata, versionEtag string) error

	// PutVersionFunc mocks the PutVersion method.
	PutVersionFunc func(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, datasetID string, edition string, version string, v datasetclient.Version) error

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserAuthToken is the userAuthToken argument value.
			UserAuthToken string
			// ServiceAuthToken is the serviceAuthToken argument value.
			ServiceAuthToken string
			// CollectionID is the collectionID argument value.
			CollectionID string
			// DatasetID is the datasetID argument value.
			DatasetID string
		}
		// GetDatasetCurrentAndNext holds details about calls to the GetDatasetCurrentAndNext method.
		GetDatasetCurrentAndNext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserAuthToken is the userAuthToken argument value.
			UserAuthToken string
			// ServiceAuthToken is the serviceAuthToken argument value.
			ServiceAuthToken string
			// CollectionID is the collectionID argument value.
			CollectionID string
			// DatasetID is the datasetID argument value.
			DatasetID string
		}
		// GetDatasetsInBatches holds details about calls to the GetDatasetsInBatches method.
		GetDatasetsInBatches []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserAuthToken is the userAuthToken argument value.
			UserAuthToken string
			// ServiceAuthToken is the serviceAuthToken argument value.
			ServiceAuthToken string
			// CollectionID is the collectionID argument value.
			CollectionID string
			// BatchSize is the batchSize argument value.
			BatchSize int
			// MaxWorkers is the maxWorkers argument value.
			MaxWorkers int
		}
		// GetEdition holds details about calls to the GetEdition method.
		GetEdition []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserAuthToken is the userAuthToken argument value.
			UserAuthToken string
			// ServiceAuthToken is the serviceAuthToken argument value.
			ServiceAuthToken string
			// CollectionID is the collectionID argument value.
			CollectionID string
			// DatasetID is the datasetID argument value.
			DatasetID string
			// Edition is the edition argument value.
			Edition string
		}
		// GetEditions holds details about calls to the GetEditions method.
		GetEditions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserAuthToken is the userAuthToken argument value.
			UserAuthToken string
			// ServiceAuthToken is the serviceAuthToken argument value.
			ServiceAuthToken string
			// CollectionID is the collectionID argument value.
			CollectionID string
			// DatasetID is the datasetID argument value.
			DatasetID string
		}
		// GetInstance holds details about calls to the GetInstance method.
		GetInstance []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserAuthToken is the userAuthToken argument value.
			UserAuthToken string
			// ServiceAuthToken is the serviceAuthToken argument value.
			ServiceAuthToken string
			// CollectionID is the collectionID argument value.
			CollectionID string
			// InstanceID is the instanceID argument value.
			InstanceID string
			// IfMatch is the ifMatch argument value.
			IfMatch string
		}
		// GetVersion holds details about calls to the GetVersion method.
		GetVersion []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserAuthToken is the userAuthToken argument value.
			UserAuthToken string
			// ServiceAuthToken is the serviceAuthToken argument value.
			ServiceAuthToken string
			// DownloadServiceAuthToken is the downloadServiceAuthToken argument value.
			DownloadServiceAuthToken string
			// CollectionID is the collectionID argument value.
			CollectionID string
			// DatasetID is the datasetID argument value.
			DatasetID string
			// Edition is the edition argument value.
			Edition string
			// Version is the version argument value.
			Version string
		}
		// GetVersionWithHeaders holds details about calls to the GetVersionWithHeaders method.
		GetVersionWithHeaders []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserAuthToken is the userAuthToken argument value.
			UserAuthToken string
			// ServiceAuthToken is the serviceAuthToken argument value.
			ServiceAuthToken string
			// DownloadServiceAuthToken is the downloadServiceAuthToken argument value.
			DownloadServiceAuthToken string
			// CollectionID is the collectionID argument value.
			CollectionID string
			// DatasetID is the datasetID argument value.
			DatasetID string
			// Edition is the edition argument value.
			Edition string
			// Version is the version argument value.
			Version string
		}
		// GetVersionsInBatches holds details about calls to the GetVersionsInBatches method.
		GetVersionsInBatches []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserAuthToken is the userAuthToken argument value.
			UserAuthToken string
			// ServiceAuthToken is the serviceAuthToken argument value.
			ServiceAuthToken string
			// DownloadServiceAuthToken is the downloadServiceAuthToken argument value.
			DownloadServiceAuthToken string
			// CollectionID is the collectionID argument value.
			CollectionID string
			// DatasetID is the datasetID argument value.
			DatasetID string
			// Edition is the edition argument value.
			Edition string
			// BatchSize is the batchSize argument value.
			BatchSize int
			// MaxWorkers is the maxWorkers argument value.
			MaxWorkers int
		}
		// PutDataset holds details about calls to the PutDataset method.
		PutDataset []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserAuthToken is the userAuthToken argument value.
			UserAuthToken string
			// ServiceAuthToken is the serviceAuthToken argument value.
			ServiceAuthToken string
			// CollectionID is the collectionID argument value.
			CollectionID string
			// DatasetID is the datasetID argument value.
			DatasetID string
			// D is the d argument value.
			D datasetclient.DatasetDetails
		}
		// PutInstance holds details about calls to the PutInstance method.
		PutInstance []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserAuthToken is the userAuthToken argument value.
			UserAuthToken string
			// ServiceAuthToken is the serviceAuthToken argument value.
			ServiceAuthToken string
			// CollectionID is the collectionID argument value.
			CollectionID string
			// InstanceID is the instanceID argument value.
			InstanceID string
			// I is the i argument value.
			I datasetclient.UpdateInstance
			// IfMatch is the ifMatch argument value.
			IfMatch string
		}
		// PutMetadata holds details about calls to the PutMetadata method.
		PutMetadata []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserAuthToken is the userAuthToken argument value.
			UserAuthToken string
			// ServiceAuthToken is the serviceAuthToken argument value.
			ServiceAuthToken string
			// CollectionID is the collectionID argument value.
			CollectionID string
			// DatasetID is the datasetID argument value.
			DatasetID string
			// Edition is the edition argument value.
			Edition string
			// Version is the version argument value.
			Version string
			// Metadata is the metadata argument value.
			Metadata datasetclient.EditableMetadata
			// VersionEtag is the versionEtag argument value.
			VersionEtag string
		}
		// PutVersion holds details about calls to the PutVersion method.
		PutVersion []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserAuthToken is the userAuthToken argument value.
			UserAuthToken string
			// ServiceAuthToken is the serviceAuthToken argument value.
			ServiceAuthToken string
			// CollectionID is the collectionID argument value.
			CollectionID string
			// DatasetID is the datasetID argument value.
			DatasetID string
			// Edition is the edition argument value.
			Edition string
			// Version is the version argument value.
			Version string
			// V is the v argument value.
			V datasetclient.Version
		}
	}
	lockGet                      sync.RWMutex
	lockGetDatasetCurrentAndNext sync.RWMutex
	lockGetDatasetsInBatches     sync.RWMutex
	lockGetEdition               sync.RWMutex
	lockGetEditions              sync.RWMutex
	lockGetInstance              sync.RWMutex
	lockGetVersion               sync.RWMutex
	lockGetVersionWithHeaders    sync.RWMutex
	lockGetVersionsInBatches     sync.RWMutex
	lockPutDataset               sync.RWMutex
	lockPutInstance              sync.RWMutex
	lockPutMetadata              sync.RWMutex
	lockPutVersion               sync.RWMutex
}

// Get calls GetFunc.
func (mock *DatasetClientMock) Get(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, datasetID string) (datasetclient.DatasetDetails, error) {
	if mock.GetFunc == nil {
		panic("DatasetClientMock.GetFunc: method is nil but DatasetClient.Get was just called")
	}
	callInfo := struct {
		Ctx              context.Context
		UserAuthToken    string
		ServiceAuthToken string
		CollectionID     string
		DatasetID        string
	}{
		Ctx:              ctx,
		UserAuthToken:    userAuthToken,
		ServiceAuthToken: serviceAuthToken,
		CollectionID:     collectionID,
		DatasetID:        datasetID,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(ctx, userAuthToken, serviceAuthToken, collectionID, datasetID)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedDatasetClient.GetCalls())
func (mock *DatasetClientMock) GetCalls() []struct {
	Ctx              context.Context
	UserAuthToken    string
	ServiceAuthToken string
	CollectionID     string
	DatasetID        string
} {
	var calls []struct {
		Ctx              context.Context
		UserAuthToken    string
		ServiceAuthToken string
		CollectionID     string
		DatasetID        string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// GetDatasetCurrentAndNext calls GetDatasetCurrentAndNextFunc.
func (mock *DatasetClientMock) GetDatasetCurrentAndNext(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, datasetID string) (datasetclient.Dataset, error) {
	if mock.GetDatasetCurrentAndNextFunc == nil {
		panic("DatasetClientMock.GetDatasetCurrentAndNextFunc: method is nil but DatasetClient.GetDatasetCurrentAndNext was just called")
	}
	callInfo := struct {
		Ctx              context.Context
		UserAuthToken    string
		ServiceAuthToken string
		CollectionID     string
		DatasetID        string
	}{
		Ctx:              ctx,
		UserAuthToken:    userAuthToken,
		ServiceAuthToken: serviceAuthToken,
		CollectionID:     collectionID,
		DatasetID:        datasetID,
	}
	mock.lockGetDatasetCurrentAndNext.Lock()
	mock.calls.GetDatasetCurrentAndNext = append(mock.calls.GetDatasetCurrentAndNext, callInfo)
	mock.lockGetDatasetCurrentAndNext.Unlock()
	return mock.GetDatasetCurrentAndNextFunc(ctx, userAuthToken, serviceAuthToken, collectionID, datasetID)
}

// GetDatasetCurrentAndNextCalls gets all the calls that were made to GetDatasetCurrentAndNext.
// Check the length with:
//
//	len(mockedDatasetClient.GetDatasetCurrentAndNextCalls())
func (mock *DatasetClientMock) GetDatasetCurrentAndNextCalls() []struct {
	Ctx              context.Context
	UserAuthToken    string
	ServiceAuthToken string
	CollectionID     string
	DatasetID        string
} {
	var calls []struct {
		Ctx              context.Context
		UserAuthToken    string
		ServiceAuthToken string
		CollectionID     string
		DatasetID        string
	}
	mock.lockGetDatasetCurrentAndNext.RLock()
	calls = mock.calls.GetDatasetCurrentAndNext
	mock.lockGetDatasetCurrentAndNext.RUnlock()
	return calls
}

// GetDatasetsInBatches calls GetDatasetsInBatchesFunc.
func (mock *DatasetClientMock) GetDatasetsInBatches(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, batchSize int, maxWorkers int) (datasetclient.List, error) {
	if mock.GetDatasetsInBatchesFunc == nil {
		panic("DatasetClientMock.GetDatasetsInBatchesFunc: method is nil but DatasetClient.GetDatasetsInBatches was just called")
	}
	callInfo := struct {
		Ctx              context.Context
		UserAuthToken    string
		ServiceAuthToken string
		CollectionID     string
		BatchSize        int
		MaxWorkers       int
	}{
		Ctx:              ctx,
		UserAuthToken:    userAuthToken,
		ServiceAuthToken: serviceAuthToken,
		CollectionID:     collectionID,
		BatchSize:        batchSize,
		MaxWorkers:       maxWorkers,
	}
	mock.lockGetDatasetsInBatches.Lock()
	mock.calls.GetDatasetsInBatches = append(mock.calls.GetDatasetsInBatches, callInfo)
	mock.lockGetDatasetsInBatches.Unlock()
	return mock.GetDatasetsInBatchesFunc(ctx, userAuthToken, serviceAuthToken, collectionID, batchSize, maxWorkers)
}

// GetDatasetsInBatchesCalls gets all the calls that were made to GetDatasetsInBatches.
// Check the length with:
//
//	len(mockedDatasetClient.GetDatasetsInBatchesCalls())
func (mock *DatasetClientMock) GetDatasetsInBatchesCalls() []struct {
	Ctx              context.Context
	UserAuthToken    string
	ServiceAuthToken string
	CollectionID     string
	BatchSize        int
	MaxWorkers       int
} {
	var calls []struct {
		Ctx              context.Context
		UserAuthToken    string
		ServiceAuthToken string
		CollectionID     string
		BatchSize        int
		MaxWorkers       int
	}
	mock.lockGetDatasetsInBatches.RLock()
	calls = mock.calls.GetDatasetsInBatches
	mock.lockGetDatasetsInBatches.RUnlock()
	return calls
}

// GetEdition calls GetEditionFunc.
func (mock *DatasetClientMock) GetEdition(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, datasetID string, edition string) (datasetclient.Edition, error) {
	if mock.GetEditionFunc == nil {
		panic("DatasetClientMock.GetEditionFunc: method is nil but DatasetClient.GetEdition was just called")
	}
	callInfo := struct {
		Ctx              context.Context
		UserAuthToken    string
		ServiceAuthToken string
		CollectionID     string
		DatasetID        string
		Edition          string
	}{
		Ctx:              ctx,
		UserAuthToken:    userAuthToken,
		ServiceAuthToken: serviceAuthToken,
		CollectionID:     collectionID,
		DatasetID:        datasetID,
		Edition:          edition,
	}
	mock.lockGetEdition.Lock()
	mock.calls.GetEdition = append(mock.calls.GetEdition, callInfo)
	mock.lockGetEdition.Unlock()
	return mock.GetEditionFunc(ctx, userAuthToken, serviceAuthToken, collectionID, datasetID, edition)
}

// GetEditionCalls gets all the calls that were made to GetEdition.
// Check the length with:
//
//	len(mockedDatasetClient.GetEditionCalls())
func (mock *DatasetClientMock) GetEditionCalls() []struct {
	Ctx              context.Context
	UserAuthToken    string
	ServiceAuthToken string
	CollectionID     string
	DatasetID        string
	Edition          string
} {
	var calls []struct {
		Ctx              context.Context
		UserAuthToken    string
		ServiceAuthToken string
		CollectionID     string
		DatasetID        string
		Edition          string
	}
	mock.lockGetEdition.RLock()
	calls = mock.calls.GetEdition
	mock.lockGetEdition.RUnlock()
	return calls
}

// GetEditions calls GetEditionsFunc.
func (mock *DatasetClientMock) GetEditions(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, datasetID string) ([]datasetclient.Edition, error) {
	if mock.GetEditionsFunc == nil {
		panic("DatasetClientMock.GetEditionsFunc: method is nil but DatasetClient.GetEditions was just called")
	}
	callInfo := struct {
		Ctx              context.Context
		UserAuthToken    string
		ServiceAuthToken string
		CollectionID     string
		DatasetID        string
	}{
		Ctx:              ctx,
		UserAuthToken:    userAuthToken,
		ServiceAuthToken: serviceAuthToken,
		CollectionID:     collectionID,
		DatasetID:        datasetID,
	}
	mock.lockGetEditions.Lock()
	mock.calls.GetEditions = append(mock.calls.GetEditions, callInfo)
	mock.lockGetEditions.Unlock()
	return mock.GetEditionsFunc(ctx, userAuthToken, serviceAuthToken, collectionID, datasetID)
}

// GetEditionsCalls gets all the calls that were made to GetEditions.
// Check the length with:
//
//	len(mockedDatasetClient.GetEditionsCalls())
func (mock *DatasetClientMock) GetEditionsCalls() []struct {
	Ctx              context.Context
	UserAuthToken    string
	ServiceAuthToken string
	CollectionID     string
	DatasetID        string
} {
	var calls []struct {
		Ctx              context.Context
		UserAuthToken    string
		ServiceAuthToken string
		CollectionID     string
		DatasetID        string
	}
	mock.lockGetEditions.RLock()
	calls = mock.calls.GetEditions
	mock.lockGetEditions.RUnlock()
	return calls
}

// GetInstance calls GetInstanceFunc.
func (mock *DatasetClientMock) GetInstance(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, instanceID string, ifMatch string) (datasetclient.Instance, string, error) {
	if mock.GetInstanceFunc == nil {
		panic("DatasetClientMock.GetInstanceFunc: method is nil but DatasetClient.GetInstance was just called")
	}
	callInfo := struct {
		Ctx              context.Context
		UserAuthToken    string
		ServiceAuthToken string
		CollectionID     string
		InstanceID       string
		IfMatch          string
	}{
		Ctx:              ctx,
		UserAuthToken:    userAuthToken,
		ServiceAuthToken: serviceAuthToken,
		CollectionID:     collectionID,
		InstanceID:       instanceID,
		IfMatch:          ifMatch,
	}
	mock.lockGetInstance.Lock()
	mock.calls.GetInstance = append(mock.calls.GetInstance, callInfo)
	mock.lockGetInstance.Unlock()
	return mock.GetInstanceFunc(ctx, userAuthToken, serviceAuthToken, collectionID, instanceID, ifMatch)
}

// GetInstanceCalls gets all the calls that were made to GetInstance.
// Check the length with:
//
//	len(mockedDatasetClient.GetInstanceCalls())
func (mock *DatasetClientMock) GetInstanceCalls() []struct {
	Ctx              context.Context
	UserAuthToken    string
	ServiceAuthToken string
	CollectionID     string
	InstanceID       string
	IfMatch          string
} {
	var calls []struct {
		Ctx              context.Context
		UserAuthToken    string
		ServiceAuthToken string
		CollectionID     string
		InstanceID       string
		IfMatch          string
	}
	mock.lockGetInstance.RLock()
	calls = mock.calls.GetInstance
	mock.lockGetInstance.RUnlock()
	return calls
}

// GetVersion calls GetVersionFunc.
func (mock *DatasetClientMock) GetVersion(ctx context.Context, userAuthToken string, serviceAuthToken string, downloadServiceAuthToken string, collectionID string, datasetID string, edition string, version string) (datasetclient.Version, error) {
	if mock.GetVersionFunc == nil {
		panic("DatasetClientMock.GetVersionFunc: method is nil but DatasetClient.GetVersion was just called")
	}
	callInfo := struct {
		Ctx                      context.Context
		UserAuthToken            string
		ServiceAuthToken         string
		DownloadServiceAuthToken string
		CollectionID             string
		DatasetID                string
		Edition                  string
		Version                  string
	}{
		Ctx:                      ctx,
		UserAuthToken:            userAuthToken,
		ServiceAuthToken:         serviceAuthToken,
		DownloadServiceAuthToken: downloadServiceAuthToken,
		CollectionID:             collectionID,
		DatasetID:                datasetID,
		Edition:                  edition,
		Version:                  version,
	}
	mock.lockGetVersion.Lock()
	mock.calls.GetVersion = append(mock.calls.GetVersion, callInfo)
	mock.lockGetVersion.Unlock()
	return mock.GetVersionFunc(ctx, userAuthToken, serviceAuthToken, downloadServiceAuthToken, collectionID, datasetID, edition, version)
}

// GetVersionWithHeaders calls GetVersionWithHeadersFunc.
func (mock *DatasetClientMock) GetVersionWithHeaders(ctx context.Context, userAuthToken string, serviceAuthToken string, downloadServiceAuthToken string, collectionID string, datasetID string, edition string, version string) (datasetclient.Version, datasetclient.ResponseHeaders, error) {
	if mock.GetVersionWithHeadersFunc == nil {
		panic("DatasetClientMock.GetVersionWithHeadersFunc: method is nil but DatasetClient.GetVersionWithHeaders was just called")
	}
	callInfo := struct {
		Ctx                      context.Context
		UserAuthToken            string
		ServiceAuthToken         string
		DownloadServiceAuthToken string
		CollectionID             string
		DatasetID                string
		Edition                  string
		Version                  string
	}{
		Ctx:                      ctx,
		UserAuthToken:            userAuthToken,
		ServiceAuthToken:         serviceAuthToken,
		DownloadServiceAuthToken: downloadServiceAuthToken,
		CollectionID:             collectionID,
		DatasetID:                datasetID,
		Edition:                  edition,
		Version:                  version,
	}
	mock.lockGetVersionWithHeaders.Lock()
	mock.calls.GetVersionWithHeaders = append(mock.calls.GetVersionWithHeaders, callInfo)
	mock.lockGetVersionWithHeaders.Unlock()
	return mock.GetVersionWithHeadersFunc(ctx, userAuthToken, serviceAuthToken, downloadServiceAuthToken, collectionID, datasetID, edition, version)
}

// GetVersionCalls gets all the calls that were made to GetVersion.
// Check the length with:
//
//	len(mockedDatasetClient.GetVersionCalls())
func (mock *DatasetClientMock) GetVersionCalls() []struct {
	Ctx                      context.Context
	UserAuthToken            string
	ServiceAuthToken         string
	DownloadServiceAuthToken string
	CollectionID             string
	DatasetID                string
	Edition                  string
	Version                  string
} {
	var calls []struct {
		Ctx                      context.Context
		UserAuthToken            string
		ServiceAuthToken         string
		DownloadServiceAuthToken string
		CollectionID             string
		DatasetID                string
		Edition                  string
		Version                  string
	}
	mock.lockGetVersion.RLock()
	calls = mock.calls.GetVersion
	mock.lockGetVersion.RUnlock()
	return calls
}

// GetVersionsInBatches calls GetVersionsInBatchesFunc.
func (mock *DatasetClientMock) GetVersionsInBatches(ctx context.Context, userAuthToken string, serviceAuthToken string, downloadServiceAuthToken string, collectionID string, datasetID string, edition string, batchSize int, maxWorkers int) (datasetclient.VersionsList, error) {
	if mock.GetVersionsInBatchesFunc == nil {
		panic("DatasetClientMock.GetVersionsInBatchesFunc: method is nil but DatasetClient.GetVersionsInBatches was just called")
	}
	callInfo := struct {
		Ctx                      context.Context
		UserAuthToken            string
		ServiceAuthToken         string
		DownloadServiceAuthToken string
		CollectionID             string
		DatasetID                string
		Edition                  string
		BatchSize                int
		MaxWorkers               int
	}{
		Ctx:                      ctx,
		UserAuthToken:            userAuthToken,
		ServiceAuthToken:         serviceAuthToken,
		DownloadServiceAuthToken: downloadServiceAuthToken,
		CollectionID:             collectionID,
		DatasetID:                datasetID,
		Edition:                  edition,
		BatchSize:                batchSize,
		MaxWorkers:               maxWorkers,
	}
	mock.lockGetVersionsInBatches.Lock()
	mock.calls.GetVersionsInBatches = append(mock.calls.GetVersionsInBatches, callInfo)
	mock.lockGetVersionsInBatches.Unlock()
	return mock.GetVersionsInBatchesFunc(ctx, userAuthToken, serviceAuthToken, downloadServiceAuthToken, collectionID, datasetID, edition, batchSize, maxWorkers)
}

// GetVersionsInBatchesCalls gets all the calls that were made to GetVersionsInBatches.
// Check the length with:
//
//	len(mockedDatasetClient.GetVersionsInBatchesCalls())
func (mock *DatasetClientMock) GetVersionsInBatchesCalls() []struct {
	Ctx                      context.Context
	UserAuthToken            string
	ServiceAuthToken         string
	DownloadServiceAuthToken string
	CollectionID             string
	DatasetID                string
	Edition                  string
	BatchSize                int
	MaxWorkers               int
} {
	var calls []struct {
		Ctx                      context.Context
		UserAuthToken            string
		ServiceAuthToken         string
		DownloadServiceAuthToken string
		CollectionID             string
		DatasetID                string
		Edition                  string
		BatchSize                int
		MaxWorkers               int
	}
	mock.lockGetVersionsInBatches.RLock()
	calls = mock.calls.GetVersionsInBatches
	mock.lockGetVersionsInBatches.RUnlock()
	return calls
}

// PutDataset calls PutDatasetFunc.
func (mock *DatasetClientMock) PutDataset(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, datasetID string, d datasetclient.DatasetDetails) error {
	if mock.PutDatasetFunc == nil {
		panic("DatasetClientMock.PutDatasetFunc: method is nil but DatasetClient.PutDataset was just called")
	}
	callInfo := struct {
		Ctx              context.Context
		UserAuthToken    string
		ServiceAuthToken string
		CollectionID     string
		DatasetID        string
		D                datasetclient.DatasetDetails
	}{
		Ctx:              ctx,
		UserAuthToken:    userAuthToken,
		ServiceAuthToken: serviceAuthToken,
		CollectionID:     collectionID,
		DatasetID:        datasetID,
		D:                d,
	}
	mock.lockPutDataset.Lock()
	mock.calls.PutDataset = append(mock.calls.PutDataset, callInfo)
	mock.lockPutDataset.Unlock()
	return mock.PutDatasetFunc(ctx, userAuthToken, serviceAuthToken, collectionID, datasetID, d)
}

// PutDatasetCalls gets all the calls that were made to PutDataset.
// Check the length with:
//
//	len(mockedDatasetClient.PutDatasetCalls())
func (mock *DatasetClientMock) PutDatasetCalls() []struct {
	Ctx              context.Context
	UserAuthToken    string
	ServiceAuthToken string
	CollectionID     string
	DatasetID        string
	D                datasetclient.DatasetDetails
} {
	var calls []struct {
		Ctx              context.Context
		UserAuthToken    string
		ServiceAuthToken string
		CollectionID     string
		DatasetID        string
		D                datasetclient.DatasetDetails
	}
	mock.lockPutDataset.RLock()
	calls = mock.calls.PutDataset
	mock.lockPutDataset.RUnlock()
	return calls
}

// PutInstance calls PutInstanceFunc.
func (mock *DatasetClientMock) PutInstance(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, instanceID string, i datasetclient.UpdateInstance, ifMatch string) (string, error) {
	if mock.PutInstanceFunc == nil {
		panic("DatasetClientMock.PutInstanceFunc: method is nil but DatasetClient.PutInstance was just called")
	}
	callInfo := struct {
		Ctx              context.Context
		UserAuthToken    string
		ServiceAuthToken string
		CollectionID     string
		InstanceID       string
		I                datasetclient.UpdateInstance
		IfMatch          string
	}{
		Ctx:              ctx,
		UserAuthToken:    userAuthToken,
		ServiceAuthToken: serviceAuthToken,
		CollectionID:     collectionID,
		InstanceID:       instanceID,
		I:                i,
		IfMatch:          ifMatch,
	}
	mock.lockPutInstance.Lock()
	mock.calls.PutInstance = append(mock.calls.PutInstance, callInfo)
	mock.lockPutInstance.Unlock()
	return mock.PutInstanceFunc(ctx, userAuthToken, serviceAuthToken, collectionID, instanceID, i, ifMatch)
}

// PutInstanceCalls gets all the calls that were made to PutInstance.
// Check the length with:
//
//	len(mockedDatasetClient.PutInstanceCalls())
func (mock *DatasetClientMock) PutInstanceCalls() []struct {
	Ctx              context.Context
	UserAuthToken    string
	ServiceAuthToken string
	CollectionID     string
	InstanceID       string
	I                datasetclient.UpdateInstance
	IfMatch          string
} {
	var calls []struct {
		Ctx              context.Context
		UserAuthToken    string
		ServiceAuthToken string
		CollectionID     string
		InstanceID       string
		I                datasetclient.UpdateInstance
		IfMatch          string
	}
	mock.lockPutInstance.RLock()
	calls = mock.calls.PutInstance
	mock.lockPutInstance.RUnlock()
	return calls
}

// PutMetadata calls PutMetadataFunc.
func (mock *DatasetClientMock) PutMetadata(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, datasetID string, edition string, version string, metadata datasetclient.EditableMetadata, versionEtag string) error {
	if mock.PutMetadataFunc == nil {
		panic("DatasetClientMock.PutMetadataFunc: method is nil but DatasetClient.PutMetadata was just called")
	}
	callInfo := struct {
		Ctx              context.Context
		UserAuthToken    string
		ServiceAuthToken string
		CollectionID     string
		DatasetID        string
		Edition          string
		Version          string
		Metadata         datasetclient.EditableMetadata
		VersionEtag      string
	}{
		Ctx:              ctx,
		UserAuthToken:    userAuthToken,
		ServiceAuthToken: serviceAuthToken,
		CollectionID:     collectionID,
		DatasetID:        datasetID,
		Edition:          edition,
		Version:          version,
		Metadata:         metadata,
		VersionEtag:      versionEtag,
	}
	mock.lockPutMetadata.Lock()
	mock.calls.PutMetadata = append(mock.calls.PutMetadata, callInfo)
	mock.lockPutMetadata.Unlock()
	return mock.PutMetadataFunc(ctx, userAuthToken, serviceAuthToken, collectionID, datasetID, edition, version, metadata, versionEtag)
}

// PutMetadataCalls gets all the calls that were made to PutMetadata.
// Check the length with:
//
//	len(mockedDatasetClient.PutMetadataCalls())
func (mock *DatasetClientMock) PutMetadataCalls() []struct {
	Ctx              context.Context
	UserAuthToken    string
	ServiceAuthToken string
	CollectionID     string
	DatasetID        string
	Edition          string
	Version          string
	Metadata         datasetclient.EditableMetadata
	VersionEtag      string
} {
	var calls []struct {
		Ctx              context.Context
		UserAuthToken    string
		ServiceAuthToken string
		CollectionID     string
		DatasetID        string
		Edition          string
		Version          string
		Metadata         datasetclient.EditableMetadata
		VersionEtag      string
	}
	mock.lockPutMetadata.RLock()
	calls = mock.calls.PutMetadata
	mock.lockPutMetadata.RUnlock()
	return calls
}

// PutVersion calls PutVersionFunc.
func (mock *DatasetClientMock) PutVersion(ctx context.Context, userAuthToken string, serviceAuthToken string, collectionID string, datasetID string, edition string, version string, v datasetclient.Version) error {
	if mock.PutVersionFunc == nil {
		panic("DatasetClientMock.PutVersionFunc: method is nil but DatasetClient.PutVersion was just called")
	}
	callInfo := struct {
		Ctx              context.Context
		UserAuthToken    string
		ServiceAuthToken string
		CollectionID     string
		DatasetID        string
		Edition          string
		Version          string
		V                datasetclient.Version
	}{
		Ctx:              ctx,
		UserAuthToken:    userAuthToken,
		ServiceAuthToken: serviceAuthToken,
		CollectionID:     collectionID,
		DatasetID:        datasetID,
		Edition:          edition,
		Version:          version,
		V:                v,
	}
	mock.lockPutVersion.Lock()
	mock.calls.PutVersion = append(mock.calls.PutVersion, callInfo)
	mock.lockPutVersion.Unlock()
	return mock.PutVersionFunc(ctx, userAuthToken, serviceAuthToken, collectionID, datasetID, edition, version, v)
}

// PutVersionCalls gets all the calls that were made to PutVersion.
// Check the length with:
//
//	len(mockedDatasetClient.PutVersionCalls())
func (mock *DatasetClientMock) PutVersionCalls() []struct {
	Ctx              context.Context
	UserAuthToken    string
	ServiceAuthToken string
	CollectionID     string
	DatasetID        string
	Edition          string
	Version          string
	V                datasetclient.Version
} {
	var calls []struct {
		Ctx              context.Context
		UserAuthToken    string
		ServiceAuthToken string
		CollectionID     string
		DatasetID        string
		Edition          string
		Version          string
		V                datasetclient.Version
	}
	mock.lockPutVersion.RLock()
	calls = mock.calls.PutVersion
	mock.lockPutVersion.RUnlock()
	return calls
}

// Ensure, that ZebedeeClientMock does implement ZebedeeClient.
// If this is not the case, regenerate this file with moq.
var _ ZebedeeClient = &ZebedeeClientMock{}

// ZebedeeClientMock is a mock implementation of ZebedeeClient.
//
//	func TestSomethingThatUsesZebedeeClient(t *testing.T) {
//
//		// make and configure a mocked ZebedeeClient
//		mockedZebedeeClient := &ZebedeeClientMock{
//			GetCollectionFunc: func(ctx context.Context, userAccessToken string, collectionID string) (zebedeeclient.Collection, error) {
//				panic("mock out the GetCollection method")
//			},
//			PutDatasetInCollectionFunc: func(ctx context.Context, userAccessToken string, collectionID string, lang string, datasetID string, state string) error {
//				panic("mock out the PutDatasetInCollection method")
//			},
//			PutDatasetVersionInCollectionFunc: func(ctx context.Context, userAccessToken string, collectionID string, lang string, datasetID string, edition string, version string, state string) error {
//				panic("mock out the PutDatasetVersionInCollection method")
//			},
//		}
//
//		// use mockedZebedeeClient in code that requires ZebedeeClient
//		// and then make assertions.
//
//	}
type ZebedeeClientMock struct {
	// GetCollectionFunc mocks the GetCollection method.
	GetCollectionFunc func(ctx context.Context, userAccessToken string, collectionID string) (zebedeeclient.Collection, error)

	// PutDatasetInCollectionFunc mocks the PutDatasetInCollection method.
	PutDatasetInCollectionFunc func(ctx context.Context, userAccessToken string, collectionID string, lang string, datasetID string, state string) error

	// PutDatasetVersionInCollectionFunc mocks the PutDatasetVersionInCollection method.
	PutDatasetVersionInCollectionFunc func(ctx context.Context, userAccessToken string, collectionID string, lang string, datasetID string, edition string, version string, state string) error

	// calls tracks calls to the methods.
	calls struct {
		// GetCollection holds details about calls to the GetCollection method.
		GetCollection []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserAccessToken is the userAccessToken argument value.
			UserAccessToken string
			// CollectionID is the collectionID argument value.
			CollectionID string
		}
		// PutDatasetInCollection holds details about calls to the PutDatasetInCollection method.
		PutDatasetInCollection []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserAccessToken is the userAccessToken argument value.
			UserAccessToken string
			// CollectionID is the collectionID argument value.
			CollectionID string
			// Lang is the lang argument value.
			Lang string
			// DatasetID is the datasetID argument value.
			DatasetID string
			// State is the state argument value.
			State string
		}
		// PutDatasetVersionInCollection holds details about calls to the PutDatasetVersionInCollection method.
		PutDatasetVersionInCollection []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserAccessToken is the userAccessToken argument value.
			UserAccessToken string
			// CollectionID is the collectionID argument value.
			CollectionID string
			// Lang is the lang argument value.
			Lang string
			// DatasetID is the datasetID argument value.
			DatasetID string
			// Edition is the edition argument value.
			Edition string
			// Version is the version argument value.
			Version string
			// State is the state argument value.
			State string
		}
	}
	lockGetCollection                 sync.RWMutex
	lockPutDatasetInCollection        sync.RWMutex
	lockPutDatasetVersionInCollection sync.RWMutex
}

// GetCollection calls GetCollectionFunc.
func (mock *ZebedeeClientMock) GetCollection(ctx context.Context, userAccessToken string, collectionID string) (zebedeeclient.Collection, error) {
	if mock.GetCollectionFunc == nil {
		panic("ZebedeeClientMock.GetCollectionFunc: method is nil but ZebedeeClient.GetCollection was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		UserAccessToken string
		CollectionID    string
	}{
		Ctx:             ctx,
		UserAccessToken: userAccessToken,
		CollectionID:    collectionID,
	}
	mock.lockGetCollection.Lock()
	mock.calls.GetCollection = append(mock.calls.GetCollection, callInfo)
	mock.lockGetCollection.Unlock()
	return mock.GetCollectionFunc(ctx, userAccessToken, collectionID)
}

// GetCollectionCalls gets all the calls that were made to GetCollection.
// Check the length with:
//
//	len(mockedZebedeeClient.GetCollectionCalls())
func (mock *ZebedeeClientMock) GetCollectionCalls() []struct {
	Ctx             context.Context
	UserAccessToken string
	CollectionID    string
} {
	var calls []struct {
		Ctx             context.Context
		UserAccessToken string
		CollectionID    string
	}
	mock.lockGetCollection.RLock()
	calls = mock.calls.GetCollection
	mock.lockGetCollection.RUnlock()
	return calls
}

// PutDatasetInCollection calls PutDatasetInCollectionFunc.
func (mock *ZebedeeClientMock) PutDatasetInCollection(ctx context.Context, userAccessToken string, collectionID string, lang string, datasetID string, state string) error {
	if mock.PutDatasetInCollectionFunc == nil {
		panic("ZebedeeClientMock.PutDatasetInCollectionFunc: method is nil but ZebedeeClient.PutDatasetInCollection was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		UserAccessToken string
		CollectionID    string
		Lang            string
		DatasetID       string
		State           string
	}{
		Ctx:             ctx,
		UserAccessToken: userAccessToken,
		CollectionID:    collectionID,
		Lang:            lang,
		DatasetID:       datasetID,
		State:           state,
	}
	mock.lockPutDatasetInCollection.Lock()
	mock.calls.PutDatasetInCollection = append(mock.calls.PutDatasetInCollection, callInfo)
	mock.lockPutDatasetInCollection.Unlock()
	return mock.PutDatasetInCollectionFunc(ctx, userAccessToken, collectionID, lang, datasetID, state)
}

// PutDatasetInCollectionCalls gets all the calls that were made to PutDatasetInCollection.
// Check the length with:
//
//	len(mockedZebedeeClient.PutDatasetInCollectionCalls())
func (mock *ZebedeeClientMock) PutDatasetInCollectionCalls() []struct {
	Ctx             context.Context
	UserAccessToken string
	CollectionID    string
	Lang            string
	DatasetID       string
	State           string
} {
	var calls []struct {
		Ctx             context.Context
		UserAccessToken string
		CollectionID    string
		Lang            string
		DatasetID       string
		State           string
	}
	mock.lockPutDatasetInCollection.RLock()
	calls = mock.calls.PutDatasetInCollection
	mock.lockPutDatasetInCollection.RUnlock()
	return calls
}

// PutDatasetVersionInCollection calls PutDatasetVersionInCollectionFunc.
func (mock *ZebedeeClientMock) PutDatasetVersionInCollection(ctx context.Context, userAccessToken string, collectionID string, lang string, datasetID string, edition string, version string, state string) error {
	if mock.PutDatasetVersionInCollectionFunc == nil {
		panic("ZebedeeClientMock.PutDatasetVersionInCollectionFunc: method is nil but ZebedeeClient.PutDatasetVersionInCollection was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		UserAccessToken string
		CollectionID    string
		Lang            string
		DatasetID       string
		Edition         string
		Version         string
		State           string
	}{
		Ctx:             ctx,
		UserAccessToken: userAccessToken,
		CollectionID:    collectionID,
		Lang:            lang,
		DatasetID:       datasetID,
		Edition:         edition,
		Version:         version,
		State:           state,
	}
	mock.lockPutDatasetVersionInCollection.Lock()
	mock.calls.PutDatasetVersionInCollection = append(mock.calls.PutDatasetVersionInCollection, callInfo)
	mock.lockPutDatasetVersionInCollection.Unlock()
	return mock.PutDatasetVersionInCollectionFunc(ctx, userAccessToken, collectionID, lang, datasetID, edition, version, state)
}

// PutDatasetVersionInCollectionCalls gets all the calls that were made to PutDatasetVersionInCollection.
// Check the length with:
//
//	len(mockedZebedeeClient.PutDatasetVersionInCollectionCalls())
func (mock *ZebedeeClientMock) PutDatasetVersionInCollectionCalls() []struct {
	Ctx             context.Context
	UserAccessToken string
	CollectionID    string
	Lang            string
	DatasetID       string
	Edition         string
	Version         string
	State           string
} {
	var calls []struct {
		Ctx             context.Context
		UserAccessToken string
		CollectionID    string
		Lang            string
		DatasetID       string
		Edition         string
		Version         string
		State           string
	}
	mock.lockPutDatasetVersionInCollection.RLock()
	calls = mock.calls.PutDatasetVersionInCollection
	mock.lockPutDatasetVersionInCollection.RUnlock()
	return calls
}

// Ensure, that BabbageClientMock does implement BabbageClient.
// If this is not the case, regenerate this file with moq.
var _ BabbageClient = &BabbageClientMock{}

// BabbageClientMock is a mock implementation of BabbageClient.
//
//	func TestSomethingThatUsesBabbageClient(t *testing.T) {
//
//		// make and configure a mocked BabbageClient
//		mockedBabbageClient := &BabbageClientMock{
//			GetTopicsFunc: func(ctx context.Context, userAccessToken string) (babbageclient.TopicsResult, error) {
//				panic("mock out the GetTopics method")
//			},
//		}
//
//		// use mockedBabbageClient in code that requires BabbageClient
//		// and then make assertions.
//
//	}
type BabbageClientMock struct {
	// GetTopicsFunc mocks the GetTopics method.
	GetTopicsFunc func(ctx context.Context, userAccessToken string) (babbageclient.TopicsResult, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetTopics holds details about calls to the GetTopics method.
		GetTopics []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserAccessToken is the userAccessToken argument value.
			UserAccessToken string
		}
	}
	lockGetTopics sync.RWMutex
}

// GetTopics calls GetTopicsFunc.
func (mock *BabbageClientMock) GetTopics(ctx context.Context, userAccessToken string) (babbageclient.TopicsResult, error) {
	if mock.GetTopicsFunc == nil {
		panic("BabbageClientMock.GetTopicsFunc: method is nil but BabbageClient.GetTopics was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		UserAccessToken string
	}{
		Ctx:             ctx,
		UserAccessToken: userAccessToken,
	}
	mock.lockGetTopics.Lock()
	mock.calls.GetTopics = append(mock.calls.GetTopics, callInfo)
	mock.lockGetTopics.Unlock()
	return mock.GetTopicsFunc(ctx, userAccessToken)
}

// GetTopicsCalls gets all the calls that were made to GetTopics.
// Check the length with:
//
//	len(mockedBabbageClient.GetTopicsCalls())
func (mock *BabbageClientMock) GetTopicsCalls() []struct {
	Ctx             context.Context
	UserAccessToken string
} {
	var calls []struct {
		Ctx             context.Context
		UserAccessToken string
	}
	mock.lockGetTopics.RLock()
	calls = mock.calls.GetTopics
	mock.lockGetTopics.RUnlock()
	return calls
}
